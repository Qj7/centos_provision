#!/usr/bin/env powscript


run_command(command, message, hide_output, allow_errors, run_as, build_fail_message)
  debug "Evaluating command: ${command}"
  if empty $message
    run_command_message=$(print_with_color "$(translate 'messages.run_command')" 'blue')
    message="$run_command_message \`$command\`"
  else
    message=$(print_with_color "${message}" 'blue')
  if isset $hide_output
    echo -en "${message} . "
  else
    echo -e "${message}"
  if isset $PRESERVE_RUNNING
    print_command_status $command 'SKIPPED' 'yellow' $hide_output
    debug "Actual running disabled"
  else
    really_run_command "${command}" "${hide_output}" "${allow_errors}" "${run_as}" "${build_fail_message}"


print_command_status(command, status, color, hide_output)
  debug "Command result: ${status}"
  if isset $hide_output
    print_with_color $status $color


really_run_command(command, hide_output, allow_errors, run_as, build_fail_message)
  save_command_script "${command}"
  local evaluated_command="./${CURRENT_COMMAND_SCRIPT}"
  evaluated_command=$(command_run_as "${evaluated_command}" "${run_as}")
  evaluated_command=$(unbuffer_streams "${evaluated_command}")
  evaluated_command=$(save_command_logs "${evaluated_command}")
  evaluated_command=$(hide_command_output "${evaluated_command}" "${hide_output}")
  debug "Real command: ${evaluated_command}"
  if ! eval "${evaluated_command}"
    print_command_status "${command}" 'NOK' 'red' "${hide_output}"
    if isset $allow_errors
      remove_current_command
      return ${FAILURE_RESULT}
    else
      current_command_fail "${build_fail_message}"
  else
    print_command_status $command 'OK' 'green' $hide_output
    remove_current_command


command_run_as(command, run_as)
  if isset $run_as
    echo "sudo -u '${run_as}' bash -c '${command}'"
  else
    echo "${command}"


# unbuffer stdout to keep stderr/stdout lines ordering
unbuffer_streams(command)
  echo "stdbuf -i0 -o0 -e0 ${command}"


save_command_logs(evaluated_command, output_log, error_log)
  save_output_log="tee -i ${CURRENT_COMMAND_OUTPUT_LOG} | tee -ia ${SCRIPT_LOG}"
  save_error_log="tee -i ${CURRENT_COMMAND_ERROR_LOG} | tee -ia ${SCRIPT_LOG}"
  echo "((${evaluated_command}) 2> >(${save_error_log}) > >(${save_output_log}))"


remove_colors_from_file(file)
  debug "Removing colors from file ${file}"
  sed -r -e 's/\x1b\[([0-9]{1,3}(;[0-9]{1,3}){,2})?[mGK]//g' -i $file


hide_command_output(command, hide_output)
  if isset $hide_output
    echo "${command} > /dev/null"
  else
    echo "${command}"


save_command_script(command)
  echo '#!/usr/bin/env bash' > "${CURRENT_COMMAND_SCRIPT}"
  echo 'set -o pipefail' >> "${CURRENT_COMMAND_SCRIPT}"
  echo -e "${command}" >> "${CURRENT_COMMAND_SCRIPT}"
  chmod a+x "${CURRENT_COMMAND_SCRIPT}"
  debug "$(print_content_of ${CURRENT_COMMAND_SCRIPT})"

current_command_fail(build_fail_message)
  remove_colors_from_file "${CURRENT_COMMAND_OUTPUT_LOG}"
  remove_colors_from_file "${CURRENT_COMMAND_ERROR_LOG}"
  if empty $build_fail_message
    build_fail_message="build_common_fail_message"
  local fail_message="$(translate 'errors.run_command.fail')\n$(eval ${build_fail_message})"
  remove_current_command
  fail "${fail_message}" "see_logs"


build_common_fail_message()
  keep_tail "${CURRENT_COMMAND_OUTPUT_LOG}"
  keep_tail "${CURRENT_COMMAND_ERROR_LOG}"
  local fail_message="$(print_content_of ${CURRENT_COMMAND_SCRIPT})"
  fail_message="${fail_message}\n$(print_content_of ${CURRENT_COMMAND_OUTPUT_LOG})"
  fail_message="${fail_message}\n$(print_content_of ${CURRENT_COMMAND_ERROR_LOG})"
  echo $fail_message


keep_tail(file)
  MAX_LINES_COUNT=20
  if $(cat "${file}" | wc -l) > $MAX_LINES_COUNT
    debug "${file} is too big, keep only ${MAX_LINES_COUNT} tail lines"
    tail -n $MAX_LINES_COUNT $file > $file.tail
    mv $file.tail $file
